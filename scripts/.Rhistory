pnt*(1-pnt)/40
(pnt*(1-pnt))/40
.001*50
p
exp(p)
pnt
pnt*(1-pnt)
pnt*(1-pnt)/40
mod3 <- lm(y ~ logx)
boxcox(mod3)
mod4 <- lm(log(y) ~ log(x), weights=1/w1)
mod4_fitted <- mod4$fitted
w4 <- (1-exp(mod4_fitted))/(n*exp(mod4_fitted))
mod5 <- lm(log(y) ~ log(x), weight=1/w4)
mod5_fitted <- mod5$fitted
plot(log(x), log(y), main="Weighted Regression with log(x) and log(y)")
points(log(x), mod5_fitted, type="l", col="green")
bc_mod <- mod5
#Part 4
predict.w=function(model,data, transform){
point=predict(model,newdata=data)
var=point*(1-point)/40
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
predict.w(bc_mod,data.frame(x=40), "log")*50
predict.w=function(model,data, transform){
point=predict(model,newdata=data)
if(transform == "log"){
point = exp(point)
}
var=point*(1-point)/40
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
predict.w(bc_mod,data.frame(x=40), "log")*50
p = predict(poly_mod, newdata=dat)
p
p*(1-p)/40
predict.w=function(model,data, transform){
point=predict(model,newdata=data)
if(transform == "log"){
point = exp(point)
}
var=point*(1-point)/40
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
predict.w(poly_mod,data.frame(x=40), "log")*50
predict.w=function(model,data, transform){
point=predict(model,newdata=data)
var=point*(1-point)/40
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
predict.w(poly_mod,data.frame(x=40), "log")*50
p = predict(poly_mod, dat)
p
p*(1-p)/40
np = predict(poly_mod,newdata=dat,interval="prediction",level=0.95,weights=1/var)
v = p*(1-p)/40
v
1/v
np = predict(poly_mod,newdata=dat,interval="prediction",level=0.95,weights=1/v)
npo
np
np*50
p
p*(1-p)/n
vp = p*(1-p)/n
1/vp
vp = p*(1-p)/40
vp
1/vp
np = predict(bc_mod,newdata=dat,interval="prediction",level=0.95,weights=1/vp)
np
exp(np)
exp(np)*50
mod3 <- lm(y ~ logx)
boxcox(mod3)
mod4 <- lm(log(y) ~ log(x), weights=1/w1)
w1
mod4_fitted <- mod4$fitted
w4 <- (1-exp(mod4_fitted))/(n*exp(mod4_fitted))
mod5 <- lm(log(y) ~ log(x), weight=1/w4)
mod5_fitted <- mod5$fitted
plot(log(x), log(y), main="Weighted Regression with log(x) and log(y)")
points(log(x), mod5_fitted, type="l", col="green")
bc_mod <- mod5
if(log){var=exp(point)*(1-exp(point))/40}
predict.w=function(model,data, transform, log=F){
point=predict(model,newdata=data)
var=point*(1-point)/40
if(log){var=exp(point)*(1-exp(point))/40}
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
predict.w(poly_mod,data.frame(x=40))*50
exp(predict.w(bc_mod, data.frame(x=40), log=T))
exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
pred_poly <- predict.w(poly_mod,data.frame(x=40))*50
pred_bc <- exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
predict.w=function(model,data, transform, log=F){
point=predict(model,newdata=data)
var=point*(1-point)/40
if(log){var=exp(point)*(1-exp(point))/40}
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
pred_poly <- predict.w(poly_mod,data.frame(x=40))*50
pred_bc <- exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
dicp <- rbinc(pred_poly, pred_bc)
dicp <- rbind(pred_poly, pred_bc)
dicp
pred_poly <- predict.w(poly_mod,data.frame(x=40))*50
pred_bc <- exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
disp <- rbinc(pred_poly, pred_bc)
disp <- rbind(pred_poly, pred_bc)
disp
disp <- rbind(pred_poly, pred_bc)
row.nameS(disp) <- c("Polynomial Model", "Box Cox Transform Model")
row.names(disp) <- c("Polynomial Model", "Box Cox Transform Model")
disp
mod3 <- lm(y ~ logx)
boxcox(mod3)
mod4 <- lm(log(y) ~ log(x), weights=1/w1)
mod4_fitted <- mod4$fitted
w4 <- (1-exp(mod4_fitted))/(n*exp(mod4_fitted))
mod5 <- lm(log(y) ~ log(x), weight=1/w4)
mod5_fitted <- mod5$fitted
plot(log(x), log(y), main="Weighted Regression with log(x) and log(y)")
points(log(x), mod5_fitted, type="l", col="green")
bc_mod <- mod5
mod2 <- lm(y ~ poly(log(x), 2), weights=1/w2)
mod2_fitted <- mod2$fitted
points(log(x), mod2$fitted, type="l", col="blue")
poly_mod <- mod2
island <- read.table("http://www.stat.cmu.edu/~roeder/stat707/=data/=data/sleuth/case2101.asc"
, header=TRUE)
x = island$area
logx = log(x)
n = island$atrisk
z = island$extinctions
y = z/n
vary <- function(phat, n){
(phat*(1-phat))/n
}
w1 <- vary(y, n)
#Regress Y on (logX)^2
mod1 <- lm(y ~ poly(logx, 2), weight=1/w1)
mod1_fitted <- mod1$fitted
plot(log(x), y, main = "Plot of the two different weighted mean functions")
points(log(x), mod1$fitted, type="l", col="red")
w2 <- vary(mod1_fitted, n)
#Use these estimated weights in a second regression
mod2 <- lm(y ~ poly(log(x), 2), weights=1/w2)
mod2_fitted <- mod2$fitted
points(log(x), mod2$fitted, type="l", col="blue")
poly_mod <- mod2
island <- read.table("http://www.stat.cmu.edu/~roeder/stat707/=data/=data/sleuth/case2101.asc"
, header=TRUE)
x = island$area
logx = log(x)
n = island$atrisk
z = island$extinctions
y = z/n
vary <- function(phat, n){
(phat*(1-phat))/n
}
w1 <- vary(y, n)
#Regress Y on (logX)^2
mod1 <- lm(y ~ poly(logx, 2), weight=1/w1)
mod1_fitted <- mod1$fitted
plot(log(x), y, main = "Plot of the two different weighted mean functions")
points(log(x), mod1$fitted, type="l", col="red")
w2 <- vary(mod1_fitted, n)
#Use these estimated weights in a second regression
mod2 <- lm(y ~ poly(log(x), 2), weights=1/w2)
mod2_fitted <- mod2$fitted
points(log(x), mod2$fitted, type="l", col="blue")
poly_mod <- mod2
#Part C
mod3 <- lm(y ~ logx)
boxcox(mod3)
mod4 <- lm(log(y) ~ log(x), weights=1/w1)
mod4_fitted <- mod4$fitted
w4 <- (1-exp(mod4_fitted))/(n*exp(mod4_fitted))
mod5 <- lm(log(y) ~ log(x), weight=1/w4)
mod5_fitted <- mod5$fitted
plot(log(x), log(y), main="Weighted Regression with log(x) and log(y)")
points(log(x), mod5_fitted, type="l", col="green")
bc_mod <- mod5
#Part 4
predict.w=function(model,data, transform, log=F){
point=predict(model,newdata=data)
var=point*(1-point)/40
if(log){var=exp(point)*(1-exp(point))/40}
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
pred_poly <- predict.w(poly_mod,data.frame(x=40))*50
pred_bc <- exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
disp <- rbind(pred_poly, pred_bc)
row.names(disp) <- c("Polynomial Model", "Box Cox Transform Model")
disp
n<-50
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
ind<-seq(1,2*n,length=10*n)/n
X1<-as.matrix(cbind(rep(1,n),x))
X2<-as.matrix(cbind(rep(1,n),x,z))
var_new<-rep(NA,length(ind))
var_new1<-rep(NA,length(ind))
for (i in 1:length(ind)){
new_pred<-c(1,ind[i],ind[i]^2)
new_pred1<-c(1,ind[i])
var_new[i]<-t(new_pred)%*%solve(t(X2)%*%X2)%*%new_pred*0.1
var_new1[i]<-t(new_pred1)%*%solve(t(X1)%*%X1)%*%new_pred1*0.1
}
plot(var_new1~ind,type="l",ylab="Risk",xlab="New x",lwd=2,ylim=c(0,0.02),main="n=50")
lines(var_new~ind,lty=2,lwd=2)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
n<-1
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
ind<-seq(1,2*n,length=10*n)/n
X1<-as.matrix(cbind(rep(1,n),x))
X2<-as.matrix(cbind(rep(1,n),x,z))
var_new<-rep(NA,length(ind))
var_new1<-rep(NA,length(ind))
for (i in 1:length(ind)){
new_pred<-c(1,ind[i],ind[i]^2)
new_pred1<-c(1,ind[i])
var_new[i]<-t(new_pred)%*%solve(t(X2)%*%X2)%*%new_pred*0.1
var_new1[i]<-t(new_pred1)%*%solve(t(X1)%*%X1)%*%new_pred1*0.1
}
plot(var_new1~ind,type="l",ylab="Risk",xlab="New x",lwd=2,ylim=c(0,0.02),main="n=50")
lines(var_new~ind,lty=2,lwd=2)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
n = 100
x = seq(1, 100, by = 2)/100
y = rep(2, n) + rnorm(n, 0, .1)
n<-1
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
ind<-seq(1,2*n,length=10*n)/n
X1<-as.matrix(cbind(rep(1,n),x))
X2<-as.matrix(cbind(rep(1,n),x,z))
var_new<-rep(NA,length(ind))
var_new1<-rep(NA,length(ind))
for (i in 1:length(ind)){
new_pred<-c(1,ind[i],ind[i]^2)
new_pred1<-c(1,ind[i])
var_new[i]<-t(new_pred)%*%solve(t(X2)%*%X2)%*%new_pred*0.1
var_new1[i]<-t(new_pred1)%*%solve(t(X1)%*%X1)%*%new_pred1*0.1
}
plot(var_new1~ind,type="l",ylab="Risk",xlab="New x",lwd=2,ylim=c(0,0.02),main="n=50")
lines(var_new~ind,lty=2,lwd=2)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
n<-100
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
ind<-seq(1,2*n,length=10*n)/n
X1<-as.matrix(cbind(rep(1,n),x))
X2<-as.matrix(cbind(rep(1,n),x,z))
var_new<-rep(NA,length(ind))
var_new1<-rep(NA,length(ind))
for (i in 1:length(ind)){
new_pred<-c(1,ind[i],ind[i]^2)
new_pred1<-c(1,ind[i])
var_new[i]<-t(new_pred)%*%solve(t(X2)%*%X2)%*%new_pred*0.1
var_new1[i]<-t(new_pred1)%*%solve(t(X1)%*%X1)%*%new_pred1*0.1
}
plot(var_new1~ind,type="l",ylab="Risk",xlab="New x",lwd=2,ylim=c(0,0.02),main="n=50")
lines(var_new~ind,lty=2,lwd=2)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
w3 <- (1-y)/ny
island <- read.table("http://www.stat.cmu.edu/~roeder/stat707/=data/=data/sleuth/case2101.asc"
, header=TRUE)
x = island$area
logx = log(x)
n = island$atrisk
z = island$extinctions
y = z/n
vary <- function(phat, n){
(phat*(1-phat))/n
}
w1 <- vary(y, n)
#Regress Y on (logX)^2
mod1 <- lm(y ~ poly(logx, 2), weight=1/w1)
mod1_fitted <- mod1$fitted
plot(log(x), y, main = "Plot of the two different weighted mean functions")
points(log(x), mod1$fitted, type="l", col="red")
w2 <- vary(mod1_fitted, n)
#Use these estimated weights in a second regression
mod2 <- lm(y ~ poly(log(x), 2), weights=1/w2)
mod2_fitted <- mod2$fitted
points(log(x), mod2$fitted, type="l", col="blue")
poly_mod <- mod2
mod2
w3 <- (1-y)/n*y
mod4 <- lm(log(y) ~ log(x), weights=1/w3)
mod4_fitted <- mod4$fitted
w4 <- (1-exp(mod4_fitted))/(n*exp(mod4_fitted))
mod5 <- lm(log(y) ~ log(x), weight=1/w4)
mod5_fitted <- mod5$fitted
plot(log(x), log(y), main="Weighted Regression with log(x) and log(y)")
points(log(x), mod5_fitted, type="l", col="green")
bc_mod <- mod5
predict.w=function(model,data, transform, log=F){
point=predict(model,newdata=data)
var=point*(1-point)/40
if(log){var=exp(point)*(1-exp(point))/40}
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
pred_poly <- predict.w(poly_mod,data.frame(x=40))*50
pred_bc <- exp(predict.w(bc_mod, data.frame(x=40), log=T))*50
disp <- rbind(pred_poly, pred_bc)
row.names(disp) <- c("Polynomial Model", "Box Cox Transform Model")
disp
island <- read.table("http://www.stat.cmu.edu/~roeder/stat707/=data/=data/sleuth/case2101.asc", header=TRUE)
attach(island)
x = area
y = extinctions/atrisk
plot(log(x), y, main= "Confidence bands for Log Squared Fit", xlab="Log Area")
out <- lm(y ~ poly(log(x), 2))
fitted <- predict(out, interval = "confidence")
lines(log(x), fitted[,"fit"])
lines(log(x), fitted[,"upr"])
lines(log(x), fitted[,"lwr"])
fitted
out <- lm(y ~ poly(log(x), 2))
predict.w=function(model,data, transform, log=F){
point=predict(model,newdata=data)
var=point*(1-point)/40
if(log){var=exp(point)*(1-exp(point))/40}
interval=predict(model,newdata=data,interval="prediction",level=0.95,weights=1/var)
return(interval)
}
out <- lm(y ~ poly(log(x), 2))
out <- lm(y ~ poly(log(x), 2))
predict.w(out,data.frame(x=40))*50
library(Sleuth2)
library(MASS)
data(case1202)
attach(case1202)
#Creating the variables
y= log(Bsal)
s=Senior
s2=s^2
a=Age
a2 = a^2
e = Educ
e2 = e^2
x = Exper
x2 = x^2
sa = s*a
se = s*e
sx = s*x
ae = a*e
ax = a*x
ex = e*x
predictors <- cbind(s, s2, a, a2, e, e2, x, x2, sa, se, sx, ae, ax, ex)
predictors_scaled <- scale(predictors)
#Set up the model with the appropriate predictors
null_mod <- lm(y ~ 1)
full_mod <- lm(y ~ s + s2 + a + a2 +e + e2 + x + x2 + sa + se + sx + ae + ax + ex, data=case1202)
#Use Stepwise regression with AIC to select the best covariates for mod1
step_forward <- stepAIC(null_mod, scope=list(lower = null_mod, upper = full_mod),
direction= "forward", quietly=TRUE)
step_forward
step_backward <- stepAIC(full_mod, scope=list(lower = null_mod, upper = full_mod),
direction= "backward")
step_backward
step_forward
step_backward
library(lars, quietly=TRUE)
?attach
n<-100
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
n
x
y
z
zx
x
n<-100
x<-seq(1,2*n,by=2)/n
y<-rep(2,n) + rnorm(n,0,0.1)
z<-x^2
ind<-seq(1,2*n,length=10*n)/n
X1<-as.matrix(cbind(rep(1,n),x))
X2<-as.matrix(cbind(rep(1,n),x,z))
var_new<-rep(NA,length(ind))
var_new1<-rep(NA,length(ind))
ind
X1
X2
var_new
var_new1
for (i in 1:length(ind)){
new_pred<-c(1,ind[i],ind[i]^2)
new_pred1<-c(1,ind[i])
var_new[i]<-t(new_pred)%*%solve(t(X2)%*%X2)%*%new_pred*0.1
var_new1[i]<-t(new_pred1)%*%solve(t(X1)%*%X1)%*%new_pred1*0.1
}
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",lwd=2,ylim=c(0,0.02),main="n=50")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",lwd=1,ylim=c(0,0.02),main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",lwd=4,ylim=c(0,0.02),main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",lwd=5,ylim=c(0,0.02),main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",main="Risk for each X")
lines(var_new~ind,lty=2,lwd=2)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, 1), main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, .2), main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, .1), main="Risk for each X")
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, .02), main="Risk for each X")
lines(var_new~ind,lty=3,lwd=2)
lines(var_new~ind,lty=1,lwd=2)
lines(var_new~ind,lty=1)
lines(rep(0.01,length(ind))~ind,lty=3,lwd=2)
lines(rep(0.01,length(ind))~ind)
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, .02), main="Risk for each X")
lines(var_new~ind,lty=1)
lines(rep(0.01,length(ind))~ind)
plot(var_new1~ind,type="l",ylab="MSE",xlab="X",ylim=c(0, .02), main="Risk for each X", col="red")
lines(var_new~ind,lty=1, col="blue")
lines(rep(0.01,length(ind))~ind, col="green")
30+50+16
96/110
# Set to directory with SQLite database
############# THIS IS A LINE YOU MUST CHANGE ##########################
setwd("C:/Users/Lee/game_simulation/data/nba")
# Read in the appropriate packages. Might have to do install.packages("RSQLite") the first time
# install.packages("RSQLite")
library("RSQLite")
library("plyr")
library("dplyr")
library("doBy")
# connect to the sqlite file
con <- dbConnect(drv="SQLite", dbname="nba.db")
alltables <- dbListTables(con)
alltables
head(dbGetQuery(con, 'SELECT * FROM game_score'))
con <- dbConnect(drv="SQLite", dbname="nba.db")
alltables <- dbListTables(con)
head(dbGetQuery(con, 'SELECT * FROM game_score'))
setwd("C:/Users/Lee/game_simulation/data/nba")
getwd()
con <- dbConnect(drv="SQLite", dbname="nba.db")
alltables <- dbListTables(con)
alltables
head(dbGetQuery(con, 'SELECT * FROM gameScore'))
head(dbGetQuery(con, 'SELECT * FROM players'))
p <- dbGetQuery(con, 'SELECT * FROM players')
dim(p)
gs <- dbGetQuery(con, 'SELECT * FROM gameScore')
dim(gs)
head(gs)
table(gs$game_year)
## SET WORKING DIRCTORY ##
setwd("C:/Users/Lee/game_simulation/scripts")
## LIBRARIES
library("dplyr")
library("e1071")
## READ IN OUR FEATURE DATASETS
large_data <- read.csv("C:/Users/Lee/game_simulation/nba_rRegression_chi//regTable.csv")
data <- read.csv("rpm_dataset.csv")
head(data)
data <- mutate(data, home = 1)
data$homeWin <- ifelse(data$home_team_score > data$visit_team_score, 1, 0)
head(data)
plot(RPM_weight.0, homeWin)
plot(data$RPM_weight.0, data$homeWin)
plot(data$homeWin, data$RPM_weight.0)
plot(data$homeWin, data$RPM_weight.0 - RPM_weight.1)
plot(data$homeWin, data$RPM_weight.0 - data$RPM_weight.1)
plot(data$homeWin, data$RPM_weight.1 - data$RPM_weight.0)
boxplotplot(data$homeWin, data$RPM_weight.1 - data$RPM_weight.0)
boxplot(data$homeWin, data$RPM_weight.1 - data$RPM_weight.0)
xtable(head(data))
library(xtable)
xtable(head(data))
xtable(head(data[,c(2:)]))
head(data)
xtable(head(data[,c(2)]))
head(data[c(1)])
head(data[c(2, 4)])
head(data[c(2, 3, 4:6)])
head(data[c(2, 3, 4:6, 8:9)])
head(data[c(2, 3, 4:6, 8:10)])
head(data[c(2, 3, 4:6, 8:10, 14:15)])
xtable(head(data[c(2, 3, 4:6, 8:10, 14:15)]))
xtable(head(data[c(2, 4, 4:6, 8:10, 14:15)]))
xtable(head(data[c(2, 4, 4:6, 9:10, 14:15)]))
head(data)
head(data[,c(9:1018)])
head(data[,c(9:10,18)])
head(data[,c(10:11,18)])
head(data[,c(10:11,14:15,18)])
xtable(head(data[,c(10:11,14:15,18)]))
hist(data$RPM_weight.0)
hist(data$RPM_weight.1)
head(data)
table(data$game_year)
