hey
head(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
Xnew <- (X-min(X))/(max(X)-min(X))
Xnew
hist(XNew
)
hist(Xnew)
hist(X)
plot(Xnew, Y)
n = length(Xnew)
x0 <- rep(1, n)
sqrt(2)
cos(1)
cosine_basis <- function(j,x){
sqrt(2)*cos(j*pi*x
}
cosine_basis <- function(j,x){
sqrt(2)*cos(j*pi*x)
}
cosine_basis(1, X)
X
cos(X)
cos(X*1*pi)
X*1
pi
X*1*pi)
X*1*pi
cos(X*1*pi)
cos(1000)
cos(1360)
?cos
cos(1:10)
typeof(X)
str(X)
cos(X)
cosine_basis <- function(j,x){
sqrt(2)*cos(round(j*pi*x, digits=1))
}
cosine_basis(1, X)
cosine_basis <- function(j,x){
sqrt(2)*(j*pi*x)
}
cosine_basis(1, X)
cos(cosine_basis(1, X))
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
sqrt(2)*cos(inside)
}
cosine_basis(1, X)
X*sqrt(2)
cosine_basis <- function(j,x){
inside <- (j*pi*x)
prod(sqrt(2),cos(inside))
}
X*sqrt(2)
cosine_basis(1, X)
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)
}
cosine_basis(1, X)
1*pi
1*pi*X
cos(1*pi*X)
cos(1*pi*X, digits=3))
cos(1*pi*X, digits=3)
cos(1*pi*X)
cos(X)
cos(1*X)
cos(pi*X)
cos(2*pi*X)
cos(3*pi*X)
cos(4*pi*X)
cos(5*pi*X)
pi*X
glmFit <- glm(Y ~ x0, family=gaussian(link="identity"))
k    <- 3
kfCV <- cv.glm(data=dfRegr, glmfit=glmFit, K=k)
?cv.glm
library(boot)
?cv.glm
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)
}
pi*X
cos(X)
cos(pi*X)
plot(X, cos(pi*X))
cosine_basis(1, Xnew)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
cosine_basis(1, Xnew)
x1 <- cosine_basis(1, Xnew)
x1
plot(Xnew, x1)
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
x6
x5
plot(Xnew, x5)
plot(Xnew, x6)
plot(Xnew, x2)
plot(Xnew, x3)
plot(Xnew, x0)
for(i in 1:6){print(i)}
plot(Xnew, Y)
mod0 <- glm(Y ~ x0, family=gaussian(link="identity"))
mod0 <- glm(Y ~ x0, family=gaussian(link="identity"))
data(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
n = length(Xnew)
Xnew <- (X-min(X))/(max(X)-min(X))
x0 <- rep(1, n)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
## Cost Function
cost = function(y, predy){
err = mean( (y-predy)^2 )
return(err)
}
## Get the fits
mod0 <- glm(Y ~ x0, family=gaussian(link="identity"))
mod1 <- glm(Y ~ x0+x1, family=gaussian(link="identity"))
mod2 <- glm(Y ~ x0+x1+x2, family=gaussian(link="identity"))
mod3 <- glm(Y ~ x0+x1+x3, family=gaussian(link="identity"))
mod4 <- glm(Y ~ x0+x1+x3+x4, family=gaussian(link="identity"))
mod5 <- glm(Y ~ x0+x1+x3+x4+x5, family=gaussian(link="identity"))
mod6 <- glm(Y ~ x0+x1+x3+x4+x5+x6, family=gaussian(link="identity"))
points(Xnew, fitted(mod6))
points(Xnew, fitted(mod6), type="l")
?cv.glm
kfCV <- cv.glm(data=ufcwc, cost=cost, glmfit=glmFit, K=k)
cbind(ufcwc, x0, x1)
ufcwc <- cbind(ufcwc, x0, x1, x2, x3, x4, x5, x6)
data(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
n = length(Xnew)
Xnew <- (X-min(X))/(max(X)-min(X))
x0 <- rep(1, n)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
ufcwc <- cbind(ufcwc, x0, x1, x2, x3, x4, x5, x6)
## Cost Function
cost = function(y, predy){
err = mean( (y-predy)^2 )
return(err)
}
## Get the fits
mod0 <- glm(Height ~ x0, family=gaussian(link="identity"), data=ufcwc)
mod1 <- glm(Height ~ x0+x1, family=gaussian(link="identity"), data=ufcwc)
mod2 <- glm(Height ~ x0+x1+x2, family=gaussian(link="identity"), data=ufcwc)
mod3 <- glm(Height ~ x0+x1+x3, family=gaussian(link="identity"), data=ufcwc)
mod4 <- glm(Height ~ x0+x1+x3+x4, family=gaussian(link="identity"), data=ufcwc)
mod5 <- glm(Height ~ x0+x1+x3+x4+x5, family=gaussian(link="identity"), data=ufcwc)
mod6 <- glm(Height ~ x0+x1+x3+x4+x5+x6, family=gaussian(link="identity"), data=ufcwc)
kfCV <- cv.glm(data=ufcwc, cost=cost, glmfit=mod0, K=4)
names(ufcwc)
data(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
n = length(Xnew)
Xnew <- (X-min(X))/(max(X)-min(X))
x0 <- rep(1, n)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
ufcwc <- cbind(ufcwc, x0, x1, x2, x3, x4, x5, x6)
## Cost Function
cost = function(y, predy){
err = mean( (y-predy)^2 )
return(err)
}
## Get the fits
mod0 <- glm(Height ~ x0, family=gaussian(link="identity"), data=ufcwc)
mod1 <- glm(Height ~ x0+x1, family=gaussian(link="identity"), data=ufcwc)
mod2 <- glm(Height ~ x0+x1+x2, family=gaussian(link="identity"), data=ufcwc)
mod3 <- glm(Height ~ x0+x1+x3, family=gaussian(link="identity"), data=ufcwc)
mod4 <- glm(Height ~ x0+x1+x3+x4, family=gaussian(link="identity"), data=ufcwc)
mod5 <- glm(Height ~ x0+x1+x3+x4+x5, family=gaussian(link="identity"), data=ufcwc)
mod6 <- glm(Height ~ x0+x1+x3+x4+x5+x6, family=gaussian(link="identity"), data=ufcwc)
ufcwc
data(ufcwc)
library(alr3)
data(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
n = length(Xnew)
Xnew <- (X-min(X))/(max(X)-min(X))
x0 <- rep(1, n)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
ufcwc <- cbind(ufcwc, x0, x1, x2, x3, x4, x5, x6)
## Cost Function
cost = function(y, predy){
err = mean( (y-predy)^2 )
return(err)
}
## Get the fits
mod0 <- glm(Height ~ x0, family=gaussian(link="identity"), data=ufcwc)
mod1 <- glm(Height ~ x0+x1, family=gaussian(link="identity"), data=ufcwc)
mod2 <- glm(Height ~ x0+x1+x2, family=gaussian(link="identity"), data=ufcwc)
mod3 <- glm(Height ~ x0+x1+x3, family=gaussian(link="identity"), data=ufcwc)
mod4 <- glm(Height ~ x0+x1+x3+x4, family=gaussian(link="identity"), data=ufcwc)
mod5 <- glm(Height ~ x0+x1+x3+x4+x5, family=gaussian(link="identity"), data=ufcwc)
mod6 <- glm(Height ~ x0+x1+x3+x4+x5+x6, family=gaussian(link="identity"), data=ufcwc)
cv.glm(data=ufcwc, cost=cost, glmfit=mod0, K=4)
cv.glm(data=ufcwc, mod0, cost=cost, K=4)
names(cv.glm(data=ufcwc, mod0, cost=cost, K=4))
cv.glm(data=ufcwc, mod0, cost=cost, K=4)$delta
cv.glm(data=ufcwc, mod0, cost=cost, K=4)$K
j=1
modj
rm(f)
rm()
rm(j)
cv.glm(data=ufcwc, mod0, cost=cost, K=3)
mod0_fit <- cv.glm(data=ufcwc, mod0, cost=cost, K=3)$delta[1]
mod0_fit <- cv.glm(data=ufcwc, mod0, cost=cost, K=3)$delta[1]## Order Results
mod0_fit <- cv.glm(data=ufcwc, mod0, cost=cost, K=3)$delta[1]
mod1_fit <- cv.glm(data=ufcwc, mod1, cost=cost, K=3)$delta[1]
mod2_fit <- cv.glm(data=ufcwc, mod2, cost=cost, K=3)$delta[1]
mod3_fit <- cv.glm(data=ufcwc, mod3, cost=cost, K=3)$delta[1]
mod4_fit <- cv.glm(data=ufcwc, mod4, cost=cost, K=3)$delta[1]
mod5_fit <- cv.glm(data=ufcwc, mod5, cost=cost, K=3)$delta[1]
mod6_fit <- cv.glm(data=ufcwc, mod6, cost=cost, K=3)$delta[1]
scores <- c(mod0_fit, mod1_fit, mod2_fit, mod3_fit, mod4_fit, mod5_fit, mod6_fit, mod7_fit)
scores <- c(mod0_fit, mod1_fit, mod2_fit, mod3_fit, mod4_fit, mod5_fit, mod6_fit)
scores
plot(scores)
min(scores)
foo = order(Xnew)
x_ord <- X[foo]
y_ord <- Y[foo]
data(ufcwc)
Y = ufcwc$Height
X = ufcwc$Dbh
n = length(Xnew)
Xnew <- (X-min(X))/(max(X)-min(X))
x0 <- rep(1, n)
## Function to compute the cosine basis
cosine_basis <- function(j,x){
inside <- (j*pi*x)
cos(inside)*sqrt(2)
}
# Get the rest of the covariates
x1 <- cosine_basis(1, Xnew)
x2 <- cosine_basis(2, Xnew)
x3 <- cosine_basis(3, Xnew)
x4 <- cosine_basis(4, Xnew)
x5 <- cosine_basis(5, Xnew)
x6 <- cosine_basis(6, Xnew)
ufcwc <- cbind(ufcwc, x0, x1, x2, x3, x4, x5, x6)
## Cost Function
cost = function(y, predy){
err = mean( (y-predy)^2 )
return(err)
}
## Get the fits
mod0 <- glm(Height ~ x0, family=gaussian(link="identity"), data=ufcwc)
mod1 <- glm(Height ~ x0+x1, family=gaussian(link="identity"), data=ufcwc)
mod2 <- glm(Height ~ x0+x1+x2, family=gaussian(link="identity"), data=ufcwc)
mod3 <- glm(Height ~ x0+x1+x3, family=gaussian(link="identity"), data=ufcwc)
mod4 <- glm(Height ~ x0+x1+x3+x4, family=gaussian(link="identity"), data=ufcwc)
mod5 <- glm(Height ~ x0+x1+x3+x4+x5, family=gaussian(link="identity"), data=ufcwc)
mod6 <- glm(Height ~ x0+x1+x3+x4+x5+x6, family=gaussian(link="identity"), data=ufcwc)
## Get CV score
mod0_fit <- cv.glm(data=ufcwc, mod0, cost=cost, K=3)$delta[1]
mod1_fit <- cv.glm(data=ufcwc, mod1, cost=cost, K=3)$delta[1]
mod2_fit <- cv.glm(data=ufcwc, mod2, cost=cost, K=3)$delta[1]
mod3_fit <- cv.glm(data=ufcwc, mod3, cost=cost, K=3)$delta[1]
mod4_fit <- cv.glm(data=ufcwc, mod4, cost=cost, K=3)$delta[1]
mod5_fit <- cv.glm(data=ufcwc, mod5, cost=cost, K=3)$delta[1]
mod6_fit <- cv.glm(data=ufcwc, mod6, cost=cost, K=3)$delta[1]
## Compare scores
scores <- c(mod0_fit, mod1_fit, mod2_fit, mod3_fit, mod4_fit, mod5_fit, mod6_fit)
## Order Results
foo = order(Xnew)
x_ord <- X[foo]
y_ord <- Y[foo]
plot(Xnew, Y)
lines(x_ord, fitted(mod6)[foo])
foo = order(Xnew)
x_ord <- Xnew[foo]
y_ord <- Y[foo]
plot(Xnew, Y)
lines(x_ord, fitted(mod6)[foo])
## SET WORKING DIRCTORY ##
setwd("C:/Users/Lee/game_simulation")
## LIBRARIES
library("dplyr")
library("e1071")
## READ IN OUR FEATURE DATASETS
data <- read.csv("scripts/rpm_dataset.csv")
## ADD home feature and win/loss column
data <- mutate(data, home = 1)
data$homeWin <- ifelse(data$home_team_score > data$visit_team_score, 1, 0)
## Set up datasets ##
years <- c(2008, 2009, 2010, 2011, 2012, 2013)
train = filter(data, game_year %in% c(2008, 2009, 2010, 2011, 2012))
test = filter(data, game_year == 2013)
xtest = test[,9:17]
ytest = test[,18]
xtrain = train[,9:17]
ytrain = train[,18]
## Naive Bayes to get probabilities
model <- naiveBayes(xtrain, ytrain)
preds <- as.data.frame(predict(model, xtest, type = c("raw"), threshold = 0.001))
preds$class <- ifelse(preds[,2] > preds[,1], 1, 0)
preds <- cbind(preds, ytest)
## Save dataset with the correct probabilities
probs <- cbind(test, preds)[, c(2:8, 17:22)]
## Rename home and away columns
names(probs)[names(probs) == "0"] <- "away_prob"
names(probs)[names(probs) == "1"] <- "home_prob"
##Create the dataset for simulation
num_seasons <- 1000
season_df <- data.frame(matrix(0, nrow=length(unique(probs$home_team)), ncol= num_seasons))
row.names(season_df) <- unique(probs$home_team)
colnames(season_df) = paste("season_", 1:1000, sep="")
## Get the unique match Id's for a given season
match_ids <- unique(probs$match_id)
setwd("C:/Users/leeri_000//game_simulation")
setwd("C:/Users/leeri_000/game_simulation")
setwd("C:/Users/leeri_000/basketball_stats/game_simulation/scripts")
setwd("C:/Users/leeri_000/basketball_stats/game_simulation")
## SET WORKING DIRCTORY ##
setwd("C:/Users/leeri_000/basketball_stats/game_simulation")
## LIBRARIES
library("dplyr")
library("e1071")
## READ IN OUR FEATURE DATASETS
data <- read.csv("scripts/rpm_dataset.csv")
## ADD home feature and win/loss column
data <- mutate(data, home = 1)
data$homeWin <- ifelse(data$home_team_score > data$visit_team_score, 1, 0)
## Set up datasets ##
years <- c(2008, 2009, 2010, 2011, 2012, 2013)
train = filter(data, game_year %in% c(2008, 2009, 2010, 2011, 2012))
test = filter(data, game_year == 2013)
xtest = test[,9:17]
ytest = test[,18]
xtrain = train[,9:17]
ytrain = train[,18]
## Naive Bayes to get probabilities
model <- naiveBayes(xtrain, ytrain)
preds <- as.data.frame(predict(model, xtest, type = c("raw"), threshold = 0.001))
preds$class <- ifelse(preds[,2] > preds[,1], 1, 0)
preds <- cbind(preds, ytest)
## Save dataset with the correct probabilities
probs <- cbind(test, preds)[, c(2:8, 17:22)]
## Rename home and away columns
names(probs)[names(probs) == "0"] <- "away_prob"
names(probs)[names(probs) == "1"] <- "home_prob"
##Create the dataset for simulation
num_seasons <- 1000
season_df <- data.frame(matrix(0, nrow=length(unique(probs$home_team)), ncol= num_seasons))
row.names(season_df) <- unique(probs$home_team)
colnames(season_df) = paste("season_", 1:1000, sep="")
## Get the unique match Id's for a given season
match_ids <- unique(probs$match_id)
head(probs)
length(probs)
dim(probs)
length(probs[,1]
)
random_outcomes <- length(probs[,1])
random_outcomes <- runif(length(probs[,1]))
hist(random_outcomes)
probs <- cbind(probs, random_outcomes)
head(probs)
head(season_df)
?apply
## SET WORKING DIRCTORY ##
setwd("C:/Users/leeri_000/basketball_stats/game_simulation")
## LIBRARIES
library("dplyr")
library("e1071")
## READ IN OUR FEATURE DATASETS
data <- read.csv("scripts/rpm_dataset.csv")
## ADD home feature and win/loss column
data <- mutate(data, home = 1)
data$homeWin <- ifelse(data$home_team_score > data$visit_team_score, 1, 0)
## Set up datasets ##
years <- c(2008, 2009, 2010, 2011, 2012, 2013)
train = filter(data, game_year %in% c(2008, 2009, 2010, 2011, 2012))
test = filter(data, game_year == 2013)
xtest = test[,9:17]
ytest = test[,18]
xtrain = train[,9:17]
ytrain = train[,18]
## Naive Bayes to get probabilities
model <- naiveBayes(xtrain, ytrain)
preds <- as.data.frame(predict(model, xtest, type = c("raw"), threshold = 0.001))
preds$class <- ifelse(preds[,2] > preds[,1], 1, 0)
preds <- cbind(preds, ytest)
## Save dataset with the correct probabilities
probs <- cbind(test, preds)[, c(2:8, 17:22)]
## Rename home and away columns
names(probs)[names(probs) == "0"] <- "away_prob"
names(probs)[names(probs) == "1"] <- "home_prob"
##Create the dataset for simulation
num_seasons <- 1000
season_df <- data.frame(matrix(0, nrow=length(unique(probs$home_team)), ncol= num_seasons))
row.names(season_df) <- unique(probs$home_team)
colnames(season_df) = paste("season_", 1:1000, sep="")
## Get the unique match Id's for a given season
match_ids <- unique(probs$match_id)
## Get random number for each_row
random_outcomes <- runif(length(probs[,1]))
probs <- cbind(probs, random_outcomes)
apply(probs, 1, function(
## Loop through each season
for(i in 1:1000){
print(paste("season", i))
## Loop through each match and probability of a season
for(match in match_ids){
# Generate uniform random number
res <- runif(1)
# Pull the relevant game
game <- probs[probs$match_id == match,]
# Using the random number, assign the winner of the game to the data frame
if(res <= game$away_prob){
## Iterate the season data frame for the away team
print("Away team wins!")
season_df[as.character(game$visit_team), i] = season_df[as.character(game$visit_team), i] + 1
} else{
print("Home Team wins!")
season_df[as.character(game$home_team), i] = season_df[as.character(game$home_team), i] + 1
}
}
}
### Check out the results
means <- apply(season_df, 1, mean)
ses <- apply(season_df, 1, sd)
detacg(package:plyr)
detach(package:plyr)
library(dplyr)
for(i in 1:1000){
print(paste("season", i))
## Loop through each match and probability of a season
for(match in match_ids){
# Generate uniform random number
res <- runif(1)
# Pull the relevant game
game <- probs[probs$match_id == match,]
# Using the random number, assign the winner of the game to the data frame
if(res <= game$away_prob){
## Iterate the season data frame for the away team
print("Away team wins!")
season_df[as.character(game$visit_team), i] = season_df[as.character(game$visit_team), i] + 1
} else{
print("Home Team wins!")
season_df[as.character(game$home_team), i] = season_df[as.character(game$home_team), i] + 1
}
}
}
### Check out the results
means <- apply(season_df, 1, mean)
ses <- apply(season_df, 1, sd)
